<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mini Car Racing Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      overflow: hidden;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      font-family: Arial, sans-serif;
      color: white;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      text-align: center;
      border-bottom: 3px solid #ffd700;
    }
    #gameTitle {
      font-size: 32px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      margin-bottom: 5px;
    }
    #author {
      font-size: 14px;
      color: #ccc;
      margin-bottom: 10px;
    }
    #score {
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      color: #fff;
    }
    canvas {
      display: block;
      background: linear-gradient(to bottom, #2d5016 0%, #1a2f0e 50%, #2d5016 100%);
      border: 4px solid #ffd700;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      margin-top: 120px;
    }
    #speedMeter {
      position: absolute;
      top: 140px;
      right: 20px;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 20px;
      border: 2px solid #ffd700;
    }
    #speedAlert {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      font-weight: bold;
      color: #ff4444;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 30px;
      border-radius: 15px;
      border: 3px solid #ff4444;
      display: none;
      animation: pulse 0.5s infinite;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: #ff4444;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
      background: rgba(0, 0, 0, 0.9);
      padding: 30px 60px;
      border-radius: 20px;
      border: 4px solid #ff4444;
      display: none;
      text-align: center;
    }
    #powerUpAlert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 28px;
      font-weight: bold;
      color: #00ff00;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 30px;
      border-radius: 15px;
      border: 3px solid #00ff00;
      display: none;
      animation: pulse 0.5s infinite;
    }
    #restartButton {
      position: absolute;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      background: linear-gradient(45deg, #ff4444, #ff6666);
      padding: 15px 30px;
      border-radius: 15px;
      border: 3px solid #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      display: none;
    }
    #restartButton:hover {
      background: linear-gradient(45deg, #ff6666, #ff8888);
      transform: translate(-50%, -50%) scale(1.1);
    }
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 15px;
      border: 2px solid #ffd700;
      opacity: 1;
      transition: opacity 1s ease-out;
    }
  </style>
</head>
<body>
  <div id="header">
    <div id="gameTitle">Car Racing Game</div>
    <div id="author">by 00sdn</div>
    <div id="score">Score: 0</div>
  </div>
  <div id="speedMeter">Speed: 60 km/h</div>
  <div id="speedAlert">SPEED INCREASED!</div>
  <div id="powerUpAlert">POWER-UP COLLECTED!</div>
  <div id="gameOver">
    <div>GAME OVER!</div>
    <div style="font-size: 24px; margin-top: 10px;">Final Score: <span id="finalScore">0</span></div>
  </div>
  <div id="restartButton">Click to Restart</div>
  <div id="controls">Use ← → Arrow Keys to move</div>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const speedMeter = document.getElementById('speedMeter');
    const speedAlert = document.getElementById('speedAlert');
    const powerUpAlert = document.getElementById('powerUpAlert');
    const gameOverScreen = document.getElementById('gameOver');
    const restartButton = document.getElementById('restartButton');
    const finalScoreDisplay = document.getElementById('finalScore');

    // Make canvas full screen
    function resizeCanvas() {
      canvas.width = window.innerWidth - 40;
      canvas.height = window.innerHeight - 160;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const carWidth = 60;
    const carHeight = 120;
    const roadWidth = canvas.width;
    const roadHeight = canvas.height;

    const player = {
      x: canvas.width / 2 - carWidth / 2,
      y: canvas.height - carHeight - 20,
      width: carWidth,
      height: carHeight,
      speed: 15,
      invincible: false,
      invincibleTime: 0
    };

    const enemies = [];
    const powerUps = [];
    const particles = [];
    let baseEnemySpeed = 4;
    let currentSpeedMultiplier = 1;
    let score = 0;
    let gameRunning = true;
    let gameTime = 0;
    let lastSpeedIncrease = 0;
    let lastPowerUpSpawn = 0;
    let roadOffset = 0;

    // Create audio context for better sound control
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Key state tracking for smooth movement
    const keys = {
      ArrowLeft: false,
      ArrowRight: false
    };

    // Hide controls after 5 seconds
    setTimeout(() => {
      const controlsElement = document.getElementById('controls');
      controlsElement.style.opacity = '0';
      setTimeout(() => {
        controlsElement.style.display = 'none';
      }, 1000);
    }, 5000);

    // Show speed alert
    function showSpeedAlert() {
      speedAlert.style.display = 'block';
      setTimeout(() => {
        speedAlert.style.display = 'none';
      }, 2000);
    }

    // Show power-up alert
    function showPowerUpAlert() {
      powerUpAlert.style.display = 'block';
      setTimeout(() => {
        powerUpAlert.style.display = 'none';
      }, 1500);
    }



    // Create crash sound
    function playCrashSound() {
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      } catch (e) {
        console.log('Audio context not available');
      }
    }

    // Create power-up sound
    function playPowerUpSound() {
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.2);
        
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
      } catch (e) {
        console.log('Audio context not available');
      }
    }

    // Create particle effect
    function createParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x + Math.random() * carWidth,
          y: y + Math.random() * carHeight,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 1,
          color: color
        });
      }
    }

    // Update particles
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life -= 0.02;
        
        if (particle.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    // Draw particles
    function drawParticles() {
      for (const particle of particles) {
        ctx.fillStyle = `rgba(${particle.color}, ${particle.life})`;
        ctx.fillRect(particle.x, particle.y, 3, 3);
      }
    }

    // Check if two cars overlap
    function carsOverlap(car1, car2) {
      return (
        car1.x < car2.x + carWidth &&
        car1.x + carWidth > car2.x &&
        car1.y < car2.y + carHeight &&
        car1.y + carHeight > car2.y
      );
    }

    // Find a safe position for new enemy car
    function findSafePosition() {
      let attempts = 0;
      let x, y;
      
      do {
        x = Math.random() * (canvas.width - carWidth);
        y = -Math.random() * canvas.height;
        attempts++;
        
        // Check if position overlaps with existing enemies
        let isSafe = true;
        for (let enemy of enemies) {
          if (carsOverlap({x: x, y: y}, enemy)) {
            isSafe = false;
            break;
          }
        }
        
        if (isSafe) {
          return {x: x, y: y};
        }
      } while (attempts < 50);
      
      return {
        x: Math.random() * (canvas.width - carWidth),
        y: -canvas.height - carHeight - Math.random() * 100
      };
    }

    // Update player movement based on key states
    function updatePlayerMovement() {
      if (keys.ArrowLeft && player.x > 0) {
        player.x -= player.speed;
      }
      if (keys.ArrowRight && player.x + carWidth < canvas.width) {
        player.x += player.speed;
      }
    }

    // Draw realistic car
    function drawCar(x, y, color, isPlayer = false) {
      // Add invincibility effect
      if (isPlayer && player.invincible) {
        ctx.globalAlpha = 0.5 + Math.sin(gameTime * 10) * 0.3;
      }
      
      // Car shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(x + 8, y + carHeight - 5, carWidth - 16, 8);
      
      // Main car body with gradient effect
      const gradient = ctx.createLinearGradient(x, y, x, y + carHeight);
      gradient.addColorStop(0, color);
      gradient.addColorStop(0.7, color);
      gradient.addColorStop(1, '#000');
      ctx.fillStyle = gradient;
      ctx.fillRect(x + 3, y + 15, carWidth - 6, carHeight - 30);
      
      // Car roof with darker shade
      const roofGradient = ctx.createLinearGradient(x, y, x, y + 40);
      roofGradient.addColorStop(0, color);
      roofGradient.addColorStop(1, '#000');
      ctx.fillStyle = roofGradient;
      ctx.fillRect(x + 8, y + 8, carWidth - 16, 35);
      
      // Windows with reflection
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(x + 10, y + 10, carWidth - 20, 30);
      
      // Window reflection
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.fillRect(x + 12, y + 12, 8, 8);
      
      // Headlights with glow effect
      ctx.fillStyle = '#FFFFE0';
      ctx.fillRect(x + 6, y + carHeight - 18, 10, 10);
      ctx.fillRect(x + carWidth - 16, y + carHeight - 18, 10, 10);
      
      // Headlight glow
      ctx.fillStyle = 'rgba(255, 255, 224, 0.4)';
      ctx.fillRect(x + 4, y + carHeight - 20, 14, 14);
      ctx.fillRect(x + carWidth - 18, y + carHeight - 20, 14, 14);
      
      // Taillights with glow
      ctx.fillStyle = '#FF4444';
      ctx.fillRect(x + 6, y + 3, 10, 10);
      ctx.fillRect(x + carWidth - 16, y + 3, 10, 10);
      
      // Taillight glow
      ctx.fillStyle = 'rgba(255, 68, 68, 0.4)';
      ctx.fillRect(x + 4, y + 1, 14, 14);
      ctx.fillRect(x + carWidth - 18, y + 1, 14, 14);
      
      // Wheels with better detail
      ctx.fillStyle = '#222';
      ctx.fillRect(x + 1, y + 12, 8, 24);
      ctx.fillRect(x + carWidth - 9, y + 12, 8, 24);
      ctx.fillRect(x + 1, y + carHeight - 36, 8, 24);
      ctx.fillRect(x + carWidth - 9, y + carHeight - 36, 8, 24);
      
      // Wheel rims with metallic effect
      const rimGradient = ctx.createRadialGradient(x + 5, y + 24, 0, x + 5, y + 24, 8);
      rimGradient.addColorStop(0, '#888');
      rimGradient.addColorStop(1, '#444');
      ctx.fillStyle = rimGradient;
      ctx.fillRect(x + 2, y + 14, 6, 20);
      ctx.fillRect(x + carWidth - 8, y + 14, 6, 20);
      ctx.fillRect(x + 2, y + carHeight - 34, 6, 20);
      ctx.fillRect(x + carWidth - 8, y + carHeight - 34, 6, 20);
      
      // Wheel hub caps
      ctx.fillStyle = '#666';
      ctx.fillRect(x + 3, y + 18, 4, 12);
      ctx.fillRect(x + carWidth - 7, y + 18, 4, 12);
      ctx.fillRect(x + 3, y + carHeight - 30, 4, 12);
      ctx.fillRect(x + carWidth - 7, y + carHeight - 30, 4, 12);
      
      // Player car has additional details
      if (isPlayer) {
        // Side mirrors with reflection
        ctx.fillStyle = color;
        ctx.fillRect(x - 4, y + 22, 4, 10);
        ctx.fillRect(x + carWidth, y + 22, 4, 10);
        
        // Mirror glass
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(x - 3, y + 23, 2, 8);
        ctx.fillRect(x + carWidth + 1, y + 23, 2, 8);
        
        // Door handle
        ctx.fillStyle = '#666';
        ctx.fillRect(x + carWidth/2 - 3, y + 42, 6, 10);
        
        // Car logo/badge
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x + carWidth/2 - 2, y + 25, 4, 4);
        
        // Exhaust pipes
        ctx.fillStyle = '#333';
        ctx.fillRect(x + 8, y + carHeight - 8, 3, 6);
        ctx.fillRect(x + carWidth - 11, y + carHeight - 8, 3, 6);
      }
      
      // Car body highlights
      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.fillRect(x + 4, y + 16, carWidth - 8, 2);
      ctx.fillRect(x + 4, y + 20, carWidth - 8, 1);
      
      // Reset global alpha
      ctx.globalAlpha = 1;
    }

    function drawRoad() {
      // Road surface with moving effect
      roadOffset += currentSpeedMultiplier * 2;
      if (roadOffset > 40) roadOffset = 0;
      
      ctx.fillStyle = '#2d5016';
      ctx.fillRect(0, 0, roadWidth, roadHeight);
      
      // Road markings with movement
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 4;
      ctx.setLineDash([20, 20]);
      
      // Center line
      ctx.beginPath();
      ctx.moveTo(roadWidth / 2, -roadOffset);
      ctx.lineTo(roadWidth / 2, roadHeight);
      ctx.stroke();
      
      // Side lines
      ctx.beginPath();
      ctx.moveTo(50, -roadOffset);
      ctx.lineTo(50, roadHeight);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(roadWidth - 50, -roadOffset);
      ctx.lineTo(roadWidth - 50, roadHeight);
      ctx.stroke();
      
      ctx.setLineDash([]);
    }

    function drawPowerUps() {
      for (const powerUp of powerUps) {
        // Power-up glow
        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.fillRect(powerUp.x - 5, powerUp.y - 5, 30, 30);
        
        // Power-up body
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(powerUp.x, powerUp.y, 20, 20);
        
        // Power-up symbol
        ctx.fillStyle = '#fff';
        ctx.fillRect(powerUp.x + 7, powerUp.y + 5, 6, 10);
        ctx.fillRect(powerUp.x + 5, powerUp.y + 7, 10, 6);
      }
    }

    function updatePowerUps() {
      // Spawn power-ups
      if (gameTime - lastPowerUpSpawn > 15) {
        powerUps.push({
          x: Math.random() * (canvas.width - 20),
          y: -20,
          speed: 3
        });
        lastPowerUpSpawn = gameTime;
      }
      
      // Update power-ups
      for (let i = powerUps.length - 1; i >= 0; i--) {
        const powerUp = powerUps[i];
        powerUp.y += powerUp.speed * currentSpeedMultiplier;
        
        // Check collision with player
        if (
          player.x < powerUp.x + 20 &&
          player.x + carWidth > powerUp.x &&
          player.y < powerUp.y + 20 &&
          player.y + carHeight > powerUp.y
        ) {
          // Collect power-up
          powerUps.splice(i, 1);
          player.invincible = true;
          player.invincibleTime = gameTime + 5; // 5 seconds of invincibility
          showPowerUpAlert();
          playPowerUpSound();
          createParticles(powerUp.x, powerUp.y, '0, 255, 0', 15);
          score += 5;
          scoreDisplay.textContent = 'Score: ' + score;
        }
        
        // Remove if off screen
        if (powerUp.y > canvas.height) {
          powerUps.splice(i, 1);
        }
      }
    }

    function updateEnemies() {
      for (let enemy of enemies) {
        enemy.y += enemy.speed * currentSpeedMultiplier;
        if (enemy.y > canvas.height) {
          // Find safe position for respawning
          const safePos = findSafePosition();
          enemy.y = safePos.y;
          enemy.x = safePos.x;
          score++;
          scoreDisplay.textContent = 'Score: ' + score;
        }
        if (
          player.x < enemy.x + carWidth &&
          player.x + carWidth > enemy.x &&
          player.y < enemy.y + carHeight &&
          player.y + carHeight > enemy.y &&
          !player.invincible
        ) {
          gameRunning = false;
          playCrashSound();
          createParticles(player.x, player.y, '255, 68, 68', 20);
          finalScoreDisplay.textContent = score;
          gameOverScreen.style.display = 'block';
          restartButton.style.display = 'block';
        }
      }
    }

    function drawEnemies() {
      for (let enemy of enemies) {
        drawCar(enemy.x, enemy.y, '#FF4444');
      }
    }

    function updateSpeed() {
      gameTime += 1/60;
      
      // Update invincibility
      if (player.invincible && gameTime > player.invincibleTime) {
        player.invincible = false;
      }
      
      // Increase speed every 10 seconds
      if (gameTime - lastSpeedIncrease >= 10) {
        currentSpeedMultiplier += 0.2;
        lastSpeedIncrease = gameTime;
        showSpeedAlert();
        const speedKmh = Math.round(60 + (currentSpeedMultiplier - 1) * 30);
        speedMeter.textContent = 'Speed: ' + speedKmh + ' km/h';
      }
    }

    function gameLoop() {
      if (!gameRunning) return;

      updateSpeed();
      updatePlayerMovement();
      updatePowerUps();
      updateParticles();
      drawRoad();
      drawCar(player.x, player.y, '#00BFFF', true);
      updateEnemies();
      drawEnemies();
      drawPowerUps();
      drawParticles();
      
      requestAnimationFrame(gameLoop);
    }

    function createEnemies(num) {
      for (let i = 0; i < num; i++) {
        const safePos = findSafePosition();
        enemies.push({
          x: safePos.x,
          y: safePos.y,
          speed: baseEnemySpeed + Math.random() * 2
        });
      }
    }

    function resetGame() {
      score = 0;
      gameTime = 0;
      lastSpeedIncrease = 0;
      lastPowerUpSpawn = 0;
      currentSpeedMultiplier = 1;
      gameRunning = true;
      player.x = canvas.width / 2 - carWidth / 2;
      player.y = canvas.height - carHeight - 20;
      player.invincible = false;
      player.invincibleTime = 0;
      enemies.length = 0;
      powerUps.length = 0;
      particles.length = 0;
      scoreDisplay.textContent = 'Score: 0';
      speedMeter.textContent = 'Speed: 60 km/h';
      gameOverScreen.style.display = 'none';
      restartButton.style.display = 'none';
      createEnemies(4);
      gameLoop();

    }

    createEnemies(4);
    gameLoop();

    document.addEventListener('keydown', (e) => {
      if (keys.hasOwnProperty(e.key)) {
        keys[e.key] = true;
        e.preventDefault();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (keys.hasOwnProperty(e.key)) {
        keys[e.key] = false;
        e.preventDefault();
      }
    });

    // Add click event for restart button
    restartButton.addEventListener('click', () => {
      resetGame();
    });
  </script>
</body>
</html>
